"use strict";(self.webpackChunknull_quiz_answers=self.webpackChunknull_quiz_answers||[]).push([[271],{6052:function(e,n,t){t.r(n),t.d(n,{Head:function(){return h},default:function(){return d}});var l=t(1151),a=t(7294);function r(e){const n=Object.assign({h1:"h1",h3:"h3",code:"code",p:"p",pre:"pre",ol:"ol",li:"li",strong:"strong"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h1,null,"async / await"),"\n",a.createElement(n.h3,null,a.createElement(n.code,null,"async / await"),"은 ES6에서 추가된 문법으로, Promise 기반의 비동기 코드를 읽기 쉽고 직관적으로 만들어줍니다."),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"async")," 키워드는 함수를 비동기 함수로 만듭니다. ",a.createElement(n.code,null,"async"),"가 선언된 함수 내에서 ",a.createElement(n.code,null,"await")," 키워드를 사용하여 비동기 작업이 완료될 때까지 기다릴 수 있습니다.\n",a.createElement(n.code,null,"await"),"은 Promise가 완료될 때까지 함수의 실행을 일시 중단합니다. 그리고 Promise가 완료되면 해당 값을 반환합니다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},'async function fetchData() {\n  const response = await fetch("https://api.example.com/data");\n  const data = await response.json();\n  return data;\n}\n')),"\n",a.createElement(n.h1,null,"왜?"),"\n",a.createElement(n.h3,null,a.createElement(n.code,null,"map()")," 메서드의 콜백 인자로 ",a.createElement(n.code,null,"async")," 함수를 전달하고 ",a.createElement(n.code,null,"await")," 처리도 잘 했는데 왜 Promise 객체가 그대로 반환될까요?"),"\n",a.createElement(n.p,null,"해당 콜백함수가 동작하는 환경에 대해 생각해봐야 합니다.\n",a.createElement(n.code,null,"map()")," 메서드는 Array 클래스의 메서드 중 하나로, 구현체는 아래와 비슷하게 생겼을 것입니다. (실제 V8엔진 구현이 js로 되어있다는 건 아닙니다.)"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"Array.prototype.map = function (callback) {\n  const result = [];\n  for (let i = 0; i < this.length; i++) {\n    const mappedValue = callback(this[i], i, this);\n    result.push(mappedValue);\n  }\n  return result;\n};\n")),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"callback"),"의 인자로 ",a.createElement(n.code,null,"async")," 함수를 전달한다면 동작할까요?\n그렇지 않겠죠."),"\n",a.createElement(n.p,null,"비동기 처리가 가능하려면 map 메서드 자체가 ",a.createElement(n.code,null,"async")," 함수가 되어 callback의 반환 값을 기다려야 합니다."),"\n",a.createElement(n.p,null,"아래와 같이요."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"Array.prototype.map = async function (callback) {\n  const result = [];\n  for (let i = 0; i < this.length; i++) {\n    const mappedValue = await callback(this[i], i, this);\n    result.push(mappedValue);\n  }\n  return result;\n};\n")),"\n",a.createElement(n.p,null,"이처럼 map() 메서드 자체가 비동기 처리를 지원하지 않기 때문에 ",a.createElement(n.code,null,"async")," 함수를 인자로 전달해도 원하는대로 동작하지 않습니다."),"\n",a.createElement(n.p,null,"콜백함수가 이행되지 않은 Promise 객체를 그대로 반환하며, 따라서 결과값으로 Promise 객체 배열을 얻게 됩니다."),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"await")," 키워드는 Promise 객체만 이행할 수 있기 때문에 아래의 ",a.createElement(n.code,null,"await")," 또한 아무것도 기다리지 않게 되죠."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"const arr = await map(someAsyncFunction); // Promise 배열\n")),"\n",a.createElement(n.p,null,"이는 Array의 순회 메서드 ",a.createElement(n.code,null,"forEach()"),", ",a.createElement(n.code,null,"reduce()"),", ",a.createElement(n.code,null,"filter()"),"등이 모두 동일합니다."),"\n",a.createElement(n.h1,null,"어떻게?"),"\n",a.createElement(n.h3,null,"그렇다면 어떻게 처리해야 좋을까요"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"for문 사용\n선언형을 포기하고 순차적으로 실행할 수 있습니다."),"\n"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"for (let i = 0; i < arr; i++) {\n  const result = await someAsyncFunc(arr[i]);\n  resultArr.push(result);\n}\n\n// for...of 도 동일\n")),"\n",a.createElement(n.p,null,"아래 방식보다 ~~간지가 안나고~~ 모든 비동기 요청을 순차적으로(waterfall) 처리해야 한다는 단점이 있습니다."),"\n",a.createElement(n.ol,{start:"2"},"\n",a.createElement(n.li,null,"Promise.all()"),"\n"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"function someFunction(array) {\n\t  return await array.map(async (item) => await someAsyncFunction(item));\n}\n\n")),"\n",a.createElement(n.p,null,"위 함수는 Promise 객체 배열을 반환한다고 했었죠.\n",a.createElement(n.code,null,"Promise.all()")," 을 통해 순회 가능한 객체 내부의 Promise의 이행을 기다리는 Promise를 받을 수 있습니다."),"\n",a.createElement(n.p,null,"[Promise.all() 이란? ->] (https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"async function someFunction(array) {\n\t  return await Promise.all(array.map(async (item) => {\n\t\t   return someAsyncFunction(item)\n      }));\n\n ...\n\n const result = async someFunction(arr); // 정상 동작\n")),"\n",a.createElement(n.p,null,"다음과 같이 사용할 수 있습니다."),"\n",a.createElement(n.p,null,"위와 같이 처리했을 때 장점은 ",a.createElement(n.code,null,"map()")," 메서드가 이행 전의 Promise 객체를 동기적으로 파바박 반환하고, ",a.createElement(n.code,null,"Promise.all()")," 은 해당 객체들을 ",a.createElement(n.strong,null,"병렬적"),"으로 처리할 수 있다는 점이에요."))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)},m=t(4630),s=t(394),o=t(837),u=t(9622);const i=s.styled.div.attrs({className:"container"}).withConfig({displayName:"mdxfrontmatter__id__Container",componentId:"sc-1gyqok2-0"})(["margin-top:15%;"]),E=s.styled.div.withConfig({displayName:"mdxfrontmatter__id__FlexEndContainer",componentId:"sc-1gyqok2-1"})(["display:flex;justify-content:end;"]);o.Z.registerLanguage("javascript",u.Z);const p=e=>{let{children:n,data:{mdx:t}}=e;const{title:l,date:r,tags:c,relatedLinks:m}=t.frontmatter;return(0,a.useEffect)((()=>{o.Z.highlightAll()}),[]),a.createElement(a.Fragment,null,a.createElement("link",{rel:"stylesheet",href:"https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/atom-one-dark.min.css"}),a.createElement(i,null,a.createElement("h1",null,l),a.createElement("div",null,a.createElement("i",null,"About "),null==c?void 0:c.map(((e,n)=>a.createElement("i",{key:n},e,n!==c.length-1&&", ")))),a.createElement(E,null,a.createElement("i",null,r)),a.createElement("hr",null)),a.createElement(i,null,a.createElement("section",null,n)),a.createElement("article",null,a.createElement("h3",null,"더 알아보려면?"),a.createElement("ul",null,null==m?void 0:m.map(((e,n)=>a.createElement("li",{key:n},a.createElement("a",{href:e||"#"},e)))))),a.createElement(E,null,a.createElement("a",{href:"https://github.com/0hhanum/null_quiz_answers/issues/new?title="+l+" 수정 요청&body=잘못된 정보를 고쳐주시면 기프티콘을 드려요 :)"},a.createElement("p",null,"잘못된 정보가 있나요?"))))};function d(e){return a.createElement(p,e,a.createElement(c,e))}const h=e=>{var n,t;let{data:l}=e;return a.createElement(m.Z,{title:(null===(n=l.mdx)||void 0===n||null===(t=n.frontmatter)||void 0===t?void 0:t.title)||""})}}}]);
//# sourceMappingURL=component---src-pages-answer-mdx-frontmatter-id-tsx-content-file-path-contents-js-map-with-async-mdx-7f2be09ec839679b6964.js.map