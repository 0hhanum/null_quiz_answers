"use strict";(self.webpackChunknull_quiz_answers=self.webpackChunknull_quiz_answers||[]).push([[463],{56:function(e,n,l){l.r(n),l.d(n,{Head:function(){return h},default:function(){return p}});var t=l(1151),r=l(7294);function c(e){const n=Object.assign({blockquote:"blockquote",p:"p",code:"code",strong:"strong",h1:"h1",pre:"pre",h2:"h2"},(0,t.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"❗️ 스코프와 클로저의 개념에 대해 자세히 다루지 않습니다."),"\n"),"\n",r.createElement(n.p,null,"함수 ",r.createElement(n.code,null,"a()"),"와 ",r.createElement(n.code,null,"b()")," 모두 콜백함수에 클로저가 사용됩니다.\n하지만 결과가 다른 이유는 두 변수의 ",r.createElement(n.strong,null,"스코프가 다르기 때문"),"입니다."),"\n",r.createElement(n.h1,null,"var는 함수 스코프, let은 블록 스코프"),"\n",r.createElement(n.p,null,"변수의 선언 방식에 따라 스코프가 달라집니다."),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"var"),"는 ",r.createElement(n.strong,null,"함수 레벨"),"의 스코프를 가지기 때문에 ",r.createElement(n.code,null,"for"),"문이 종료되어도 ",r.createElement(n.code,null,"함수 a"),"의 스코프 내에서 참조가 가능합니다. 아래처럼요."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-javascript"},"function example() {\n  for (var i = 0; i < 10; i++) {\n    // do something\n  }\n  console.log(i); // 10\n}\n")),"\n",r.createElement(n.p,null,"하지만 ",r.createElement(n.code,null,"let"),"은 ",r.createElement(n.strong,null,"블록 레벨")," 스코프를 가지기 때문에 ",r.createElement(n.code,null,"for"),"문이 종료되면 해당 블록 내에서 선언한 변수는 접근할 수 없습니다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-javascript"},"function example() {\n  for (let i = 0; i < 10; i++) {\n    // do something\n  }\n  console.log(i); // Uncaught ReferenceError: i is not defined\n}\n")),"\n",r.createElement(n.p,null,"그럼 ",r.createElement(n.code,null,"for문"),"도 함수 실행도 종료된 이후 ",r.createElement(n.code,null,"setTimeout"),"내 콜백에서 ",r.createElement(n.code,null,"i"),"를 참조할 수 있는 이유는 무엇일까요?"),"\n",r.createElement(n.h1,null,"클로저"),"\n",r.createElement(n.p,null,"콜백 함수가 외부 스코프의 참조를 가지고 있어 클로저가 형성되어 ",r.createElement(n.code,null,"a()"),", ",r.createElement(n.code,null,"b()"),"의 실행이 완료된 후에도 해당 값을 저장하고 참조를 유지할 수 있기 때문입니다."),"\n",r.createElement(n.h2,null,"let"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"let")," 키워드는 각 ",r.createElement(n.code,null,"for")," 반복문의 블록마다(반복마다) 변수 ",r.createElement(n.code,null,"i"),"에 대해 ",r.createElement(n.strong,null,"독립된 블록 스코프"),"를 생성합니다.\n따라서 콜백 함수는 고유한 ",r.createElement(n.code,null,"i")," 값에 대한 참조를 유지하는 클로저를 생성하게 됩니다."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"코드 상으로는 변수 선언이 한번이지만 블록 스코프를 가지는 ",r.createElement(n.code,null,"let"),"의 특성상 매 순회마다 새로 선언, 할당이 발생하는 것처럼 동작합니다."),'\n(* 실제로는 각 반복마다 변수가 "새로 선언"되는 것이 아니라, 단일 선언이 블록 스코프 내에서 각기 다른 인스턴스로 처리됨)'),"\n",r.createElement(n.p,null,"결과적으로 0~9 까지 순회하며 10개의 독립적인 변수 i를 기억하며, 각각 다른 값(0~9)이 출력됩니다."),"\n",r.createElement(n.h2,null,"var"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"var"),"의 경우 함수 레벨 스코프를 가지기 때문에 함수 ",r.createElement(n.code,null,"b")," 내부가 변수 ",r.createElement(n.code,null,"i"),"의 스코프가 됩니다.\n따라서 순회문 내에서도 동일한 ",r.createElement(n.code,null,"i"),"를 참조하며, 콜백함수 또한 마찬가지로 동일한 변수 ",r.createElement(n.code,null,"i"),"를 참조하게 됩니다._createMdxContent\n10개의 콜백함수가 모두 동일한 ",r.createElement(n.code,null,"i"),"를 참조하기 때문에 콜백함수 실행 시점의 ",r.createElement(n.code,null,"i")," 값인 10이 10번 출력되게 됩니다."),"\n",r.createElement(n.p,null,"위와 같이 변수 선언 방식은 코드의 동작 방식에 영향을 줍니다.\n불필요한 오류를 방지하기 위해선 팀 내 변수 선언 방식을 한 가지로 통일하는 것이 좋겠죠?"),"\n",r.createElement(n.p,null,"스코프 외에도 재선언 방지, TDZ 생성 등 잠재적인 오류를 막기 위해 개선된 변수 선언 방식인\n",r.createElement(n.code,null,"const"),", ",r.createElement(n.code,null,"let"),"을 사용하는 것이 모던 자바스크립트에선 권장됩니다."))}var a=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?r.createElement(n,e,r.createElement(c,e)):c(e)},u=l(4630),m=l(394),o=l(837),i=l(9622);const E=m.styled.div.attrs({className:"container"}).withConfig({displayName:"mdxfrontmatter__id__Container",componentId:"sc-1gyqok2-0"})(["margin-top:15%;"]),s=m.styled.div.withConfig({displayName:"mdxfrontmatter__id__FlexEndContainer",componentId:"sc-1gyqok2-1"})(["display:flex;justify-content:end;"]);o.Z.registerLanguage("javascript",i.Z);const d=e=>{let{children:n,data:{mdx:l}}=e;const{title:t,date:c,tags:a,relatedLinks:u}=l.frontmatter;return(0,r.useEffect)((()=>{o.Z.highlightAll()}),[]),r.createElement(r.Fragment,null,r.createElement("link",{rel:"stylesheet",href:"https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/atom-one-dark.min.css"}),r.createElement(E,null,r.createElement("h1",null,t),r.createElement("div",null,r.createElement("i",null,"About "),null==a?void 0:a.map(((e,n)=>r.createElement("i",{key:n},e,n!==a.length-1&&", ")))),r.createElement(s,null,r.createElement("i",null,c)),r.createElement("hr",null)),r.createElement(E,null,r.createElement("section",null,n)),r.createElement("article",null,r.createElement("h3",null,"더 알아보려면?"),r.createElement("ul",null,null==u?void 0:u.map(((e,n)=>r.createElement("li",{key:n},r.createElement("a",{href:e||"#"},e)))))),r.createElement(s,null,r.createElement("a",{href:"https://github.com/0hhanum/null_quiz_answers/issues/new?title="+t+" 수정 요청&body=잘못된 정보를 고쳐주시면 기프티콘을 드려요 :)"},r.createElement("p",null,"잘못된 정보가 있나요?"))))};function p(e){return r.createElement(d,e,r.createElement(a,e))}const h=e=>{var n,l;let{data:t}=e;return r.createElement(u.Z,{title:(null===(n=t.mdx)||void 0===n||null===(l=n.frontmatter)||void 0===l?void 0:l.title)||""})}}}]);
//# sourceMappingURL=component---src-pages-answer-mdx-frontmatter-id-tsx-content-file-path-contents-js-variable-scope-mdx-f66cb4a4f585a571398a.js.map