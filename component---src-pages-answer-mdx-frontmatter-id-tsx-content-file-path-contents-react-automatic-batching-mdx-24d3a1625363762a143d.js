"use strict";(self.webpackChunknull_quiz_answers=self.webpackChunknull_quiz_answers||[]).push([[999],{304:function(e,t,n){n.r(t),n.d(t,{Head:function(){return h},default:function(){return d}});var l=n(1151),a=n(7294);function c(e){const t=Object.assign({h1:"h1",p:"p",pre:"pre",code:"code"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.h1,null,"batching?"),"\n",a.createElement(t.p,null,"배칭이란 리액트가 더 나은 성능을 위해 여러 상태 업데이트를 하나로 묶어 리렌더링 하는 것을 의미합니다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-javascript"},"const Component = () => {\n  const [state1, setState1] = useState(true);\n  const [state2, setState2] = useState(true);\n\n  const onClick = () => {\n    setState1(false); // 리렌더링 전\n    setState2(true); // 리렌더링 전\n    // **핸들러 함수가 마무리되면 리렌더링\n  };\n\n  ...\n};\n")),"\n",a.createElement(t.p,null,"리액트는 상태 변경에 대응해 리렌더링합니다."),"\n",a.createElement(t.p,null,"하지만 위 경우, ",a.createElement(t.code,null,"setState1"),"과 ",a.createElement(t.code,null,"setState2"),"에 모두 반응하여 두 번 리렌더링한다면 성능적으로 좋지 않겠죠?"),"\n",a.createElement(t.p,null,"또한 절반만 완료된 업데이트가 반영되어 의도하지 않은 상태 조합을 가질 수도 있습니다."),"\n",a.createElement(t.p,null,"이를 위해 리액트 팀은 ",a.createElement(t.code,null,"batching"),"이라는 개념을 도입했습니다."),"\n",a.createElement(t.p,null,"동시에 일어나는 상태 변경을 한 번에 처리해 렌더링 횟수를 최적화합니다."),"\n",a.createElement("mark",null,"하지만 React 17까지는 이벤트 핸들러 밖에서 발생하는 업데이트에 대해서는 배칭하지 않았습니다."),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-javascript"},"const Component = () => {\n  const [state1, setState1] = useState(true);\n  const [state2, setState2] = useState(true);\n\n  const onClick = () => {\n    fetchiApi().then(() => {\n      // onClick 핸들러가 마무리 된 후에 실행\n      // fetchApi의 콜백으로 동작\n      setState1(false); // 리렌더링\n      setState2(true); // 리렌더링\n    })\n  };\n\n  ...\n};\n")),"\n",a.createElement(t.p,null,"위 예시처럼, ",a.createElement(t.code,null,"onClick")," 함수가 종료된 후에 실행되는 비동기 요청에 대한 콜백이나,"),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"setTimeout"),", ",a.createElement(t.code,null,"Promise")," 혹은 네이티브 이벤트에 대한 핸들러 내부의 업데이트는 배칭되지 않았습니다."),"\n",a.createElement(t.p,null,"리렌더링이 두 번 발생하고 있죠."),"\n",a.createElement(t.p,null,"이를 해결하기 위해 React 18에서 ",a.createElement(t.code,null,"Automatic batching"),"이 소개됩니다."),"\n",a.createElement(t.h1,null,"Automatic batching"),"\n",a.createElement(t.p,null,"React 18의 ",a.createElement(t.code,null,"createRoot"),"로 생성된 루트 내의 모든 업데이트는 어디서 왔는가와 무관하게 자동으로 배칭됩니다."),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"timeout"),", ",a.createElement(t.code,null,"Promise"),"등의 비동기 처리 콜백이나 외부(네이티브) 이벤트 핸들러에 대해서도 배칭이 동작합니다."),"\n",a.createElement(t.p,null,"리액트 팀은 이를 ",a.createElement(t.code,null,"Automatic batching"),"이라고 소개했습니다."),"\n",a.createElement("b",null,"신기한 점은 자동 배칭이 짧은 tick 동안 쌓여있는 업데이트들을 묶어 실행한다는 것입니다."),"\n",a.createElement("br"),"\n",a.createElement("br"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-javascript"},"const Component = () => {\n  const [state1, setState1] = useState(true);\n  const [state2, setState2] = useState(true);\n  const onClick = async () => {\n    setState1((curr) => !curr); \n    setState2((curr) => !curr); // 리렌더링\n    const state = await getServerState(); // 비동기 데이터 waiting\n    setState1(state);\n    setState2(state); // 리렌더링\n    // -------- 한 번에 리렌더링 --------- //\n    setTimeout(() => {\n      setState1((curr) => !curr);\n      setState2((curr) => !curr);\n    }, 100);\n    setTimeout(() => {\n      setState1((curr) => !curr);\n      setState2((curr) => !curr);\n    }, 100);\n    // ------------------------------- //\n  };\n};\n")),"\n",a.createElement(t.p,null,"퀴즈 정답은 3 입니다."),"\n",a.createElement(t.p,null,"핸들러 내부의 업데이트는 배칭 처리를 할 수 있다고 쳐도, 언제 끝날 지 모르는 외부 업데이트를 어떻게 배치 처리 하는지 신기하지 않나요?"),"\n",a.createElement(t.p,null,"내부적으로 타이머를 돌리는건지, 동작원리가 궁금해져 찾아본 결과 리액트 팀의 답변을 찾았습니다."),"\n",a.createElement("blockquote",null,a.createElement(t.p,null,'"실질적으로 말하자면, React가 \'조금 기다린다\'는 것을 의미합니다 ("작업 또는 마이크로 태스크가 끝날 때까지"인 경우 기술 용어). 그러면 React가 화면을 업데이트합니다."'),a.createElement("footer",null,a.createElement("cite",null,"https://github.com/reactwg/react-18/discussions/46#discussioncomment-846862"))),"\n",a.createElement(t.p,null,"간단하게 리액트가 ",a.createElement(t.code,null,"batching")," 중일시 업데이트를 큐에 쌓아두고 마이크로 태스크 큐가 비면 배칭된 업데이트를 실행한다는 식의 답변을 확인했습니다."),"\n",a.createElement(t.p,null,"위의 코드를 테스트해보면 100ms의 ",a.createElement(t.code,null,"setTimeout"),"이 두 개 돌아가고 있는데도 배칭되어 실행됩니다."),"\n",a.createElement(t.p,null,"재미있는 테스트를 해보겠습니다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-javascript"},'const Component = () => {\n  const [state1, setState1] = useState(0);\n  const [state2, setState2] = useState(0);\n  console.log("rendered", state1, state2)\n  const onClick = () => {\n    // setTimeout1\n    setTimeout(() => { \n      setState1(1);\n      setState2(1);\n    }, 100);\n    // setTimeout2\n    setTimeout(() => {\n      setState1(2);\n      setState2(2);\n    }, 101);\n  };\n};\n')),"\n",a.createElement(t.p,null,"위 테스트의 결과는 어떨 것 같나요?"),"\n",a.createElement(t.p,null,"1ms 차이를 두고 배치 처리가 되는지 테스트하는 코드입니다."),"\n",a.createElement(t.p,null,"결과는 일관적이지 않습니다."),"\n",a.createElement("b",null,a.createElement(t.code,null,"setTimeout1"),"과 ",a.createElement(t.code,null,"setTimeout2"),"가 동시에 실행되기도, 묶여 실행되기도 합니다."),"\n",a.createElement(t.p,null,"DOM 페인팅이라던지 어떤 이벤트들이 마이크로태스크큐에 남아있다면 묶여 처리되는걸로 예상됩니다."),"\n",a.createElement(t.p,null,"리액트 팀의 답변 이해를 돕는 테스트랄까요."),"\n",a.createElement(t.p,null,"재미있죠?"))}var r=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.ah)(),e.components);return t?a.createElement(t,e,a.createElement(c,e)):c(e)},s=n(4630),u=n(394),m=n(837),o=n(9622);const i=u.styled.div.attrs({className:"container"}).withConfig({displayName:"mdxfrontmatter__id__Container",componentId:"sc-1gyqok2-0"})(["margin-top:15%;"]),E=u.styled.div.withConfig({displayName:"mdxfrontmatter__id__FlexEndContainer",componentId:"sc-1gyqok2-1"})(["display:flex;justify-content:end;"]);m.Z.registerLanguage("javascript",o.Z);const p=e=>{let{children:t,data:{mdx:n}}=e;const{title:l,date:c,tags:r,relatedLinks:s}=n.frontmatter;return(0,a.useEffect)((()=>{m.Z.highlightAll()}),[]),a.createElement(a.Fragment,null,a.createElement("link",{rel:"stylesheet",href:"https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/atom-one-dark.min.css"}),a.createElement(i,null,a.createElement("h1",null,l),a.createElement("div",null,a.createElement("i",null,"About "),null==r?void 0:r.map(((e,t)=>a.createElement("i",{key:t},e,t!==r.length-1&&", ")))),a.createElement(E,null,a.createElement("i",null,c)),a.createElement("hr",null)),a.createElement(i,null,a.createElement("section",null,t)),a.createElement("article",null,a.createElement("h3",null,"더 알아보려면?"),a.createElement("ul",null,null==s?void 0:s.map(((e,t)=>a.createElement("li",{key:t},a.createElement("a",{href:e||"#"},e)))))),a.createElement(E,null,a.createElement("a",{href:"https://github.com/0hhanum/null_quiz_answers/issues/new?title="+l+" 수정 요청&body=잘못된 정보를 고쳐주시면 기프티콘을 드려요 :)"},a.createElement("p",null,"잘못된 정보가 있나요?"))))};function d(e){return a.createElement(p,e,a.createElement(r,e))}const h=e=>{var t,n;let{data:l}=e;return a.createElement(s.Z,{title:(null===(t=l.mdx)||void 0===t||null===(n=t.frontmatter)||void 0===n?void 0:n.title)||""})}}}]);
//# sourceMappingURL=component---src-pages-answer-mdx-frontmatter-id-tsx-content-file-path-contents-react-automatic-batching-mdx-24d3a1625363762a143d.js.map